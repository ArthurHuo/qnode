/*
 * See Copyright Notice in qnode.h
 */

#include "qevent.h"
#include "qmalloc.h"
#include "qminheap.h"

int min_heap_elem_greater(struct qnode_event_t *add, struct qnode_event_t *b) {
      return evutil_timercmp(&add->ev_timeout, &b->ev_timeout, >);
}

void qnode_minheap_ctor(qnode_minheap_t* s) {
  s->events = NULL;
  s->size = 0;
  s->add = 0;
}

void qnode_minheap_dtor(qnode_minheap_t* s) {
  if(s->events) {
    qnode_free(s->events);
  }
}

void qnode_minheap_elem_init(struct qnode_event_t* e) {
  e->min_heap_idx = -1;
}

int qnode_minheap_empty(qnode_minheap_t* s) {
  return 0u == s->size;
}

unsigned int qnode_minheap_size(qnode_minheap_t* s) {
  return s->size;
}

struct qnode_event_t* qnode_minheap_top(qnode_minheap_t* s) {
  return s->size ? *s->events : NULL;
}

int qnode_minheap_reserve(qnode_minheap_t* s, unsigned int size) {
  if(s->add < size) {
    struct qnode_event_t** events;
    unsigned add = s->add ? s->add * 2 : 8;
    if(add < size)
      add = size;
    events = (struct qnode_t**)qrealloc(s->events, add * sizeof (*events));
    if(!events) {
      return -1;
    }
    s->events = events;
    s->add = add;
  }
  return 0;
}

void min_heap_shift_up(qnode_minheap_t* s, unsigned hole_index, struct qnode_event_t* e) {
  unsigned parent = (hole_index - 1) / 2;
  while(hole_index && qnode_minheap_elem_greater(s->events[parent], e)) {
    (s->events[hole_index] = s->events[parent])->min_heap_idx = hole_index;
    hole_index = parent;
    parent = (hole_index - 1) / 2;
  }
  (s->events[hole_index] = e)->min_heap_idx = hole_index;
}

void min_heap_shift_down(qnode_minheap_t* s, unsigned hole_index, struct qnode_event_t* e) {
  unsigned min_child = 2 * (hole_index + 1);
  while(min_child <= s->size) {
    min_child -= min_child == s->size || min_heap_elem_greater(s->events[min_child], s->events[min_child - 1]);
    if(!(min_heap_elem_greater(e, s->events[min_child])))
      break;
    (s->events[hole_index] = s->events[min_child])->qnode_minheap_idx = hole_index;
    hole_index = min_child;
    min_child = 2 * (hole_index + 1);
  }
  min_heap_shift_up(s, hole_index,  e);
}


int qnode_minheap_push(qnode_minheap_t* s, struct qnode_event_t* e) {
  if(qnode_minheap_reserve(s, s->size + 1)) {
    return -1;
  }
  min_heap_shift_up(s, s->size++, e);
  return 0;
}

struct qnode_event_t* qnode_minheap_pop(qnode_minheap_t* s) {
  if(s->size) {
    struct qnode_event_t* e = *s->events;
    min_heap_shift_down(s, 0u, s->events[--s->size]);
    e->min_heap_idx = -1;
    return e;
  }
  return 0;
}

int qnode_minheap_erase(qnode_minheap_t* s, struct qnode_event_t* e) {
  if(((unsigned int)-1) != e->min_heap_idx) {
    struct qnode_event_t *last = s->events[--s->size];
    unsigned parent = (e->min_heap_idx - 1) / 2;
    if (e->min_heap_idx > 0 && min_heap_elem_greater(s->events[parent], last))
      min_heap_shift_up_(s, e->min_heap_idx, last);
    else
      min_heap_shift_down(s, e->min_heap_idx, last);
    e->min_heap_idx = -1;
    return 0;
  }
  return -1;
}
